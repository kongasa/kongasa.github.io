(self.webpackChunkkongasa_blog=self.webpackChunkkongasa_blog||[]).push([[762],{5806:(n,s,a)=>{"use strict";a.r(s),a.d(s,{data:()=>e});const e={key:"v-2cf854b7",path:"/learning/others/linux-list-head.html",title:"Linux list_head",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"learning/others/linux-list-head.md",git:{updatedTime:1620285788e3}}},9050:(n,s,a)=>{"use strict";a.r(s),a.d(s,{default:()=>m});var e=a(6252);const t=(0,e.Wm)("h1",{id:"linux-list-head"},[(0,e.Wm)("a",{class:"header-anchor",href:"#linux-list-head"},"#"),(0,e.Uk)(" Linux list_head")],-1),p=(0,e.Wm)("p",null,"参考：",-1),o={href:"https://www.cnblogs.com/zhuyp1015/archive/2012/06/02/2532240.html",target:"_blank",rel:"noopener noreferrer"},c=(0,e.Uk)("Linux 内核list_head 学习（一）"),l={href:"https://www.zhihu.com/question/49164544/answer/301969545",target:"_blank",rel:"noopener noreferrer"},u=(0,e.Uk)("C 语言中，「.」与「->」有什么区别？"),r=(0,e.uE)('<p>Linux 的链表很有意思。</p><p>linux 的链表只包含两个指针，是一个双向循环有头节点的链表结构。它不包含其他数据结构，其他数据结构包含它，头节点不被包含。</p><p>给出链表节点地址，节点数据类型，链表数据类型（对于链表永远是 <code>list_head</code>，但是这个宏是通用的），就可以得到包含列表的节点的地址。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">offsetof</span><span class="token expression"><span class="token punctuation">(</span>TYPE<span class="token punctuation">,</span>MEMBER<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TYPE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>MEMBER<span class="token punctuation">)</span></span></span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">container_of</span><span class="token expression"><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span>type<span class="token punctuation">,</span>member<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>type<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token operator">-</span><span class="token function">offsetof</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>member<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>offsetof</code> 的设计非常精妙。它相当于是程序员向编译器发问，「假如， MEMBER 所属的对象地址在 0，那你应该能帮我拿到 MEMBER 吧？我知道你不会真的去访问内存，引起中断，导致崩溃。把它的地址给我就行。」</p><p>因为对象从 0 地址开始，offsetof 返回的值就是 MEMBER 的偏移量。</p><p><code>container_of</code> 故技重施，是 <code>offsetof</code> 的反向操作。</p><p>关于为什么 <code>((TYPE*) 0)-&gt;MEMBER</code> 不会发生内存访问。请看</p>',8),i={href:"https://www.zhihu.com/question/49164544/answer/301969545",target:"_blank",rel:"noopener noreferrer"},k=(0,e.Uk)("C 语言中，「.」与「->」有什么区别？"),d=(0,e.Wm)("p",null,[(0,e.Uk)("使用 "),(0,e.Wm)("code",null,"."),(0,e.Uk)(" 的表达式（一个变量也是表达式，而且 "),(0,e.Wm)("code",null,"a.b"),(0,e.Uk)(" 不是变量，因为 "),(0,e.Wm)("code",null,"."),(0,e.Uk)(" 是个操作符 ）是左值还是右值取决于 "),(0,e.Wm)("code",null,"."),(0,e.Uk)(" 的左操作数，而使用 "),(0,e.Wm)("code",null,"->"),(0,e.Uk)(" 的表达式将永远是个左值。访问地址是运行时发生的，但是因为这个宏并没有用到地址上的数据，编译后的机器码并不会发生内存访问，也就不会发生中断。改一改编译器的话，这个宏就可能出问题。")],-1),m={render:function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.j4)(e.HY,null,[t,p,(0,e.Wm)("p",null,[(0,e.Wm)("a",o,[c,(0,e.Wm)(a)])]),(0,e.Wm)("p",null,[(0,e.Wm)("a",l,[u,(0,e.Wm)(a)])]),r,(0,e.Wm)("p",null,[(0,e.Wm)("a",i,[k,(0,e.Wm)(a)])]),d],64)}}}}]);