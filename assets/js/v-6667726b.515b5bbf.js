(self.webpackChunkkongasa_blog=self.webpackChunkkongasa_blog||[]).push([[281],{6277:(a,e,r)=>{"use strict";r.r(e),r.d(e,{data:()=>t});const t={key:"v-6667726b",path:"/learning/others/c-macro.html",title:"C macro",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"learning/others/c-macro.md",git:{updatedTime:1620285788e3}}},6102:(a,e,r)=>{"use strict";r.r(e),r.d(e,{default:()=>s});var t=r(6252);const l=(0,t.Wm)("h1",{id:"c-macro"},[(0,t.Wm)("a",{class:"header-anchor",href:"#c-macro"},"#"),(0,t.Uk)(" C macro")],-1),c=(0,t.Wm)("p",null,"macro：micro 的反义词，直译是「宏」。",-1),n=(0,t.Wm)("p",null,"但是这个名字没法表现出宏到底是个什么东西。在魔兽里看宏真的很让人费解。不如翻译成一坨。",-1),o=(0,t.Wm)("p",null,"宏是一种类似速记的方式，它是面向编译的。在 C 中，使用宏定义的语句会在预编译阶段被转换为相应的字符串，预编译的语法类似与面向字符串的脚本语言，所以如果不是有意为之，不要在宏的末尾加分号。",-1),m=(0,t.Wm)("p",null,"不同的语言里宏有不同的实现，在 Rust 里会在编译时对宏进行展开，记录到 AST 中。",-1),s={render:function(a,e){return(0,t.wg)(),(0,t.j4)(t.HY,null,[l,c,n,o,m],64)}}}}]);